import java.io.*;
import java.util.*;
class HallBooking implements Runnable {
	public HallBooking(String hallName, double cost, int hallCapacity, int seatsBooked) {

		HallName = hallName;
		this.cost = cost;
		HallCapacity = hallCapacity;
		SeatsBooked = seatsBooked;
	}
	public HallBooking() {
		this.HallName = null;
		this.cost = 0;
		this.HallCapacity = 0;
		this.SeatsBooked = 0;
	}
	private String HallName;
	private double cost;
	private int HallCapacity;
	private int SeatsBooked;
	public String getHallName() {
		return HallName;
	}
	public void setHallName(String hallName) {
		HallName = hallName;
	}
	public double getCost() {
		return cost;
	}
	public void setCost(double cost) {
		this.cost = cost;
	}
	public int getHallCapacity() {
		return HallCapacity;
	}
	public void setHallCapacity(int hallCapacity) {
		HallCapacity = hallCapacity;
	}
	public int getSeatsBooked() {
		return SeatsBooked;
	}
	public void setSeatsBooked(int seatsBooked) {
		SeatsBooked = seatsBooked;
	}
	@Override
	public void run() {
		int res = this.SeatsBooked* 100;
		if(res > cost) {
			System.out.println("Profit");
		}
		else
			System.out.println("Loss");
		
	}
}
class Main {
public static void main(String [] args) {
	int i,n;
	Scanner sc = new Scanner(System.in);
	n = Integer.parseInt(sc.nextLine());
	for(i=0;i<n;i++) {
		HallBooking h = new HallBooking();
		h.setHallName(sc.nextLine());
		h.setCost(Double.parseDouble(sc.nextLine()));
		h.setHallCapacity(Integer.parseInt(sc.nextLine()));
		h.setSeatsBooked(Integer.parseInt(sc.nextLine()));
		Thread t = new Thread(h);
		t.start();
	}
}
}
-----------------------------------------------
import java.util.Scanner;

class AttendanceCounter implements Runnable {
    private int[] attendance;
    private int start;
    private int end;
    private int count = 0;

    public AttendanceCounter(int[] attendance, int start, int end) {
        this.attendance = attendance;
        this.start = start;
        this.end = end;
    }

    public int getCount() {
        return count;
    }

    @Override
    public void run() {
        for (int i = start; i < end; i++) {
            if (attendance[i] == 100) {
                count++;
            }
        }
    }
}

public class AttendanceApp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] attendance = new int[n];

        for (int i = 0; i < n; i++) {
            attendance[i] = sc.nextInt();
        }

        int mid = n / 2;

        AttendanceCounter counter1 = new AttendanceCounter(attendance, 0, mid);
        AttendanceCounter counter2 = new AttendanceCounter(attendance, mid, n);

        Thread thread1 = new Thread(counter1);
        Thread thread2 = new Thread(counter2);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int totalWinners = counter1.getCount() + counter2.getCount();
        System.out.println("Winners : " + totalWinners);

        sc.close();
    }
}


thread1.join(); makes the main thread (or the thread that calls join()) wait until thread1 finishes its execution.
Let’s break it down simply:

thread1.start(); → Starts running thread1 independently.
thread1.join(); → Tells the current thread (like main()) to pause and wait until thread1 completes its task.


---------------------------------------------------------------------FA_-----------------------------------------
class EvenAndOdd {
    private int number = 1;
    private final int limit = 20;

    public synchronized void printOdd() {
        while (number <= limit) {
            if (number % 2 == 0) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (number <= limit) {
                System.out.println("Thread Odd: " + number);
                number++;
                notify();
            }
        }
    }

    public synchronized void printEven() {
        while (number <= limit) {
            if (number % 2 != 0) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (number <= limit) {
                System.out.println("Thread even: " + number);
                number++;
                notify();
            }
        }
    }

    public static void main(String[] args) {
        EvenAndOdd evenAndOdd = new EvenAndOdd();

        Thread oddThread = new Thread(() -> evenAndOdd.printOdd());
        Thread evenThread = new Thread(() -> evenAndOdd.printEven());

        oddThread.start();
        evenThread.start();
    }
}
//()-> evenAndOdd.printOdd():
//This is a lambda expression — a shortcut for writing an anonymous function. In Java, the Runnable interface has a single method,
run(), and lambdas are perfect for this kind of situation.
//() means this lambda takes no arguments.
-----------------------------------------------------------------------------------------
import java.util.Scanner;

class Stall implements Runnable {
    private String stallName;
    private String details;
    private double stallArea;
    private String owner;
    private double stallCost;

    public Stall(String stallName, String details, double stallArea, String owner) {
        this.stallName = stallName;
        this.details = details;
        this.stallArea = stallArea;
        this.owner = owner;
    }

    @Override
    public void run() {
        this.stallCost = this.stallArea * 150.0;
        System.out.println(this.stallCost);
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.nextLine());

        for (int i = 0; i < n; i++) {
            String stallName = sc.nextLine();
            String details = sc.nextLine();
            double stallArea = Double.parseDouble(sc.nextLine());
            String owner = sc.nextLine();

            Stall st = new Stall(stallName, details, stallArea, owner);
            Thread s = new Thread(st);
            s.start();
        }
        sc.close();
    }
}

in above program since the Main function doesnt have any other stmts to be printed after the threads, so no join method is reqd here.

Why Thread.sleep() is not ideal:
------------------------------------------
Blind waiting: It pauses the thread for a fixed time without knowing if the condition it’s waiting for is ready.
Wasted CPU time: Even if the resource becomes available earlier, the thread still waits for the full sleep time.
No lock release: sleep() holds onto the object’s lock, which can lead to deadlocks or blocked threads.
Why wait() and notify() are better:

Smart waiting: wait() only pauses until notified, so it resumes execution as soon as the other thread signals readiness.
Efficient CPU usage: Threads don’t waste time sleeping when they could proceed immediately.
Releases the lock: wait() releases the object’s lock while waiting, allowing other threads to access shared resources.
